(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3774],{3905:function(n,e,t){"use strict";t.d(e,{Zo:function(){return c},kt:function(){return m}});var r=t(7294);function a(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){a(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function p(n,e){if(null==n)return{};var t,r,a=function(n,e){if(null==n)return{};var t,r,a={},i=Object.keys(n);for(r=0;r<i.length;r++)t=i[r],e.indexOf(t)>=0||(a[t]=n[t]);return a}(n,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(r=0;r<i.length;r++)t=i[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(a[t]=n[t])}return a}var l=r.createContext({}),s=function(n){var e=r.useContext(l),t=e;return n&&(t="function"==typeof n?n(e):o(o({},e),n)),t},c=function(n){var e=s(n.components);return r.createElement(l.Provider,{value:e},n.children)},u={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},d=r.forwardRef((function(n,e){var t=n.components,a=n.mdxType,i=n.originalType,l=n.parentName,c=p(n,["components","mdxType","originalType","parentName"]),d=s(t),m=a,g=d["".concat(l,".").concat(m)]||d[m]||u[m]||i;return t?r.createElement(g,o(o({ref:e},c),{},{components:t})):r.createElement(g,o({ref:e},c))}));function m(n,e){var t=arguments,a=e&&e.mdxType;if("string"==typeof n||a){var i=t.length,o=new Array(i);o[0]=d;var p={};for(var l in e)hasOwnProperty.call(e,l)&&(p[l]=e[l]);p.originalType=n,p.mdxType="string"==typeof n?n:a,o[1]=p;for(var s=2;s<i;s++)o[s]=t[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},7535:function(n,e,t){"use strict";t.r(e),t.d(e,{frontMatter:function(){return p},contentTitle:function(){return l},metadata:function(){return s},toc:function(){return c},default:function(){return d}});var r=t(4034),a=t(9973),i=(t(7294),t(3905)),o=["components"],p={},l="Go Adaptor Pattern",s={unversionedId:"Programming/Design Pattern/Patterns/Adaptor/Go",id:"Programming/Design Pattern/Patterns/Adaptor/Go",isDocsHomePage:!1,title:"Go Adaptor Pattern",description:"Adaptor",source:"@site/docs/Programming/Design Pattern/Patterns/Adaptor/Go.md",sourceDirName:"Programming/Design Pattern/Patterns/Adaptor",slug:"/Programming/Design Pattern/Patterns/Adaptor/Go",permalink:"/docs/Programming/Design Pattern/Patterns/Adaptor/Go",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"SRP (Single Responsibility Principle)",permalink:"/docs/Programming/Design Pattern/Principle/SRP"},next:{title:"Overview",permalink:"/docs/Programming/Design Pattern/Patterns/Adaptor/Overview"}},c=[{value:"Adaptor",id:"adaptor",children:[],level:3},{value:"Caching",id:"caching",children:[],level:3},{value:"References",id:"references",children:[],level:2}],u={toc:c};function d(n){var e=n.components,t=(0,a.Z)(n,o);return(0,i.kt)("wrapper",(0,r.Z)({},u,t,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"go-adaptor-pattern"},"Go Adaptor Pattern"),(0,i.kt)("h3",{id:"adaptor"},"Adaptor"),(0,i.kt)("p",null,"In the example, we are given a ",(0,i.kt)("inlineCode",{parentName:"p"},"VectorImage")," and we want to adapt to a ",(0,i.kt)("inlineCode",{parentName:"p"},"RasterImage")," in order to output to console."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"This is the given interface")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"type Line struct {\n  X1, Y1, X2, Y2 int\n}\n\ntype VectorImage struct {\n  Lines []Line\n}\n\nfunc NewRectangle(width, height int) *VectorImage {\n  width -= 1\n  height -= 1\n  return &VectorImage{[]Line {\n    Line{0, 0, width, 0},\n    Line{0, 0, 0, height},\n    Line{width, 0, width, height},\n    Line{0, height, width, height}}}\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"This is the desired interfaces")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"type Point struct {\n  X, Y int\n}\n\ntype RasterImage interface {\n  GetPoints() []Point\n}\n\nfunc DrawPoints(owner RasterImage) string {\n  maxX, maxY := 0, 0\n  points := owner.GetPoints()\n  for _, pixel := range points {\n    if pixel.X > maxX { maxX = pixel.X }\n    if pixel.Y > maxY { maxY = pixel.Y }\n  }\n  maxX += 1\n  maxY += 1\n\n  data := make([][]rune, maxY)\n  for i := 0; i < maxY; i++ {\n    data[i] = make([]rune, maxX)\n    for j := range data[i] { data[i][j] = ' ' }\n  }\n\n  for _, point := range points {\n    data[point.Y][point.X] = '*'\n  }\n\n  b := strings.Builder{}\n  for _, line := range data {\n    b.WriteString(string(line))\n    b.WriteRune('\\n')\n  }\n\n  return b.String()\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"This is the adaptor")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'type vectorToRasterAdapter struct {\n  points []Point\n}\n\n\nfunc minmax (a, b int) (int, int) {\n  if a < b {\n    return a, b\n  } else {\n    return b, a\n  }\n}\n\nfunc (a *vectorToRasterAdapter) addLine(line Line) {\n  left, right := minmax(line.X1, line.X2)\n  top, bottom := minmax(line.Y1, line.Y2)\n  dx := right - left\n  dy := line.Y2 - line.Y1\n\n  if dx == 0 {\n    for y := top; y <= bottom; y++ {\n      a.points = append(a.points, Point{left, y})\n    }\n  } else if dy == 0 {\n    for x := left; x <= right; x++ {\n      a.points = append(a.points, Point{x, top})\n    }\n  }\n\n  fmt.Println("generated", len(a.points), "points")\n}\n\nfunc (a vectorToRasterAdapter) GetPoints() []Point {\n  return a.points\n}\n\nfunc VectorToRaster(vi *VectorImage) RasterImage {\n  adapter := vectorToRasterAdapter{}\n  for _, line := range vi.Lines {\n    // Or adapter.addLineCached(line)\n    adapter.addLine(line)\n  }\n\n  return adapter // as RasterImage\n}\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"This is the main function")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"func main() {\n  rc := NewRectangle(6, 4)\n  a := VectorToRaster(rc) // adapter!\n  _ = VectorToRaster(rc)  // adapter!\n  fmt.Print(DrawPoints(a))\n}\n")),(0,i.kt)("h3",{id:"caching"},"Caching"),(0,i.kt)("p",null,"We use a cache to store the results."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'var pointCache = map[[16]byte] []Point{}\n\nfunc (a *vectorToRasterAdapter) addLineCached(line Line) {\n  hash := func (obj interface{}) [16]byte {\n    bytes, _ := json.Marshal(obj)\n    return md5.Sum(bytes)\n  }\n  h := hash(line)\n  if pts, ok := pointCache[h]; ok {\n    for _, pt := range pts {\n      a.points = append(a.points, pt)\n    }\n    return\n  }\n\n  left, right := minmax(line.X1, line.X2)\n  top, bottom := minmax(line.Y1, line.Y2)\n  dx := right - left\n  dy := line.Y2 - line.Y1\n\n  if dx == 0 {\n    for y := top; y <= bottom; y++ {\n      a.points = append(a.points, Point{left, y})\n    }\n  } else if dy == 0 {\n    for x := left; x <= right; x++ {\n      a.points = append(a.points, Point{x, top})\n    }\n  }\n\n  // be sure to add these to the cache\n  pointCache[h] = a.points\n  fmt.Println("generated", len(a.points), "points")\n}\n')),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.udemy.com/course/design-patterns-go"},"https://www.udemy.com/course/design-patterns-go"))))}d.isMDXComponent=!0}}]);