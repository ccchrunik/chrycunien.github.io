(self.webpackChunkyingchiaochen_website=self.webpackChunkyingchiaochen_website||[]).push([[2849],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return m}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||i;return n?r.createElement(h,o(o({ref:t},p),{},{components:n})):r.createElement(h,o({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},438:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return d}});var r=n(4034),a=n(9973),i=(n(7294),n(3905)),o=["components"],s={},l="P4 Lab",c={unversionedId:"System/Network/Virtualization/P4/P4-Lab",id:"System/Network/Virtualization/P4/P4-Lab",isDocsHomePage:!1,title:"P4 Lab",description:"In this lab, we modify a tutorial from the offical tutorials. The original one is to do source routing, but we modify it to use label to route the packet.",source:"@site/docs/System/Network/Virtualization/P4/P4-Lab.md",sourceDirName:"System/Network/Virtualization/P4",slug:"/System/Network/Virtualization/P4/P4-Lab",permalink:"/docs/System/Network/Virtualization/P4/P4-Lab",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Multicast",permalink:"/docs/System/Distributed/Concepts/Multicast"},next:{title:"P4 Overview",permalink:"/docs/System/Network/Virtualization/P4/P4-Overview"}},p=[{value:"Topology",id:"topology",children:[],level:2},{value:"Source Code",id:"source-code",children:[],level:2},{value:"Entries Injection",id:"entries-injection",children:[],level:2},{value:"Prerequisite",id:"prerequisite",children:[],level:2},{value:"Steps",id:"steps",children:[],level:2},{value:"Result",id:"result",children:[],level:2},{value:"References",id:"references",children:[],level:2}],u={toc:p};function d(e){var t=e.components,s=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},u,s,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"p4-lab"},"P4 Lab"),(0,i.kt)("p",null,"In this lab, we modify a ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/p4lang/tutorials/tree/master/exercises/source_routing"},"tutorial")," from the offical tutorials. The original one is to do source routing, but we modify it to use label to route the packet."),(0,i.kt)("h2",{id:"topology"},"Topology"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"topology",src:n(5635).Z})),(0,i.kt)("h2",{id:"source-code"},"Source Code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c++",metastring:'title="source_routing.p4"',title:'"source_routing.p4"'},"/* -*- P4_16 -*- */\n#include <core.p4>\n#include <v1model.p4>\n\nconst bit<16> TYPE_IPV4 = 0x800;\nconst bit<16> TYPE_SRCROUTING = 0x1234;\n\n#define MAX_HOPS 9\n\n/*************************************************************************\n*********************** H E A D E R S  ***********************************\n*************************************************************************/\n\ntypedef bit<9>  egressSpec_t;\ntypedef bit<48> macAddr_t;\ntypedef bit<32> ip4Addr_t;\n\nheader ethernet_t {\n    macAddr_t dstAddr;\n    macAddr_t srcAddr;\n    bit<16>   etherType;\n}\n\nheader srcRoute_t {\n    bit<1>    bos;\n    bit<15>   port;\n}\n\nheader ipv4_t {\n    bit<4>    version;\n    bit<4>    ihl;\n    bit<8>    diffserv;\n    bit<16>   totalLen;\n    bit<16>   identification;\n    bit<3>    flags;\n    bit<13>   fragOffset;\n    bit<8>    ttl;\n    bit<8>    protocol;\n    bit<16>   hdrChecksum;\n    ip4Addr_t srcAddr;\n    ip4Addr_t dstAddr;\n}\n\nstruct metadata {\n    /* empty */\n}\n\nstruct headers {\n    ethernet_t              ethernet;\n    srcRoute_t[MAX_HOPS]    srcRoutes;\n    ipv4_t                  ipv4;\n}\n\n/*************************************************************************\n*********************** P A R S E R  ***********************************\n*************************************************************************/\n\nparser MyParser(packet_in packet,\n                out headers hdr,\n                inout metadata meta,\n                inout standard_metadata_t standard_metadata) {\n    \n    state start {\n        transition parse_ethernet;\n    }\n\n    state parse_ethernet {\n        packet.extract(hdr.ethernet);\n        transition select(hdr.ethernet.etherType) {\n            TYPE_SRCROUTING: parse_srcRouting;\n            default: accept;\n        }\n    }\n\n    state parse_srcRouting {\n        packet.extract(hdr.srcRoutes.next);\n        transition select(hdr.srcRoutes.last.bos) {\n            1: parse_ipv4;\n            default: parse_srcRouting;\n        }\n    }\n\n    state parse_ipv4 {\n        packet.extract(hdr.ipv4);\n        transition accept;\n    }\n\n}\n\n\n/*************************************************************************\n************   C H E C K S U M    V E R I F I C A T I O N   *************\n*************************************************************************/\n\ncontrol MyVerifyChecksum(inout headers hdr, inout metadata meta) {   \n    apply {  }\n}\n\n\n/*************************************************************************\n**************  I N G R E S S   P R O C E S S I N G   *******************\n*************************************************************************/\n\ncontrol MyIngress(inout headers hdr,\n                  inout metadata meta,\n                  inout standard_metadata_t standard_metadata) {\n\n    action drop() {\n        mark_to_drop(standard_metadata);\n    }\n    \n    action update_ttl(){\n        hdr.ipv4.ttl = hdr.ipv4.ttl - 1;\n    }\n\n    action label_output(egressSpec_t port) {\n        standard_metadata.egress_spec = port;\n    }\n\n    action pop_label_output(egressSpec_t port) {\n        hdr.ethernet.etherType = TYPE_IPV4;\n        standard_metadata.egress_spec = port;\n        hdr.srcRoutes.pop_front(1);\n    }\n\n    table label_exact {\n        key = {\n            hdr.srcRoutes[0].port: exact;\n        }\n        actions = {\n            label_output;\n            pop_label_output;\n            drop;\n            NoAction;\n        }\n        size = 1024;\n        default_action = drop();\n    }\n\n    \n    apply {\n        if (hdr.srcRoutes[0].isValid()){\n            if (hdr.ipv4.isValid()){\n                update_ttl();\n            }\n            if (hdr.srcRoutes[0].bos == 1){\n                label_exact.apply();\n            }\n        } else{\n            drop();\n        } \n    }\n}\n\n/*************************************************************************\n****************  E G R E S S   P R O C E S S I N G   *******************\n*************************************************************************/\n\ncontrol MyEgress(inout headers hdr,\n                 inout metadata meta,\n                 inout standard_metadata_t standard_metadata) {\n    apply {  }\n}\n\n/*************************************************************************\n*************   C H E C K S U M    C O M P U T A T I O N   **************\n*************************************************************************/\n\ncontrol MyComputeChecksum(inout headers  hdr, inout metadata meta) {\n    apply {\n        update_checksum(\n            hdr.ipv4.isValid(),\n            { hdr.ipv4.version,\n              hdr.ipv4.ihl,\n              hdr.ipv4.diffserv,\n              hdr.ipv4.totalLen,\n              hdr.ipv4.identification,\n              hdr.ipv4.flags,\n              hdr.ipv4.fragOffset,\n              hdr.ipv4.ttl,\n              hdr.ipv4.protocol,\n              hdr.ipv4.srcAddr,\n              hdr.ipv4.dstAddr },\n            hdr.ipv4.hdrChecksum,\n            HashAlgorithm.csum16);\n    }\n}\n\n/*************************************************************************\n***********************  D E P A R S E R  *******************************\n*************************************************************************/\n\ncontrol MyDeparser(packet_out packet, in headers hdr) {\n    apply {\n        packet.emit(hdr.ethernet);\n        packet.emit(hdr.srcRoutes);\n        packet.emit(hdr.ipv4);\n    }\n}\n\n/*************************************************************************\n***********************  S W I T C H  *******************************\n*************************************************************************/\n\nV1Switch(\nMyParser(),\nMyVerifyChecksum(),\nMyIngress(),\nMyEgress(),\nMyComputeChecksum(),\nMyDeparser()\n) main;\n")),(0,i.kt)("h2",{id:"entries-injection"},"Entries Injection"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="s1-runtime.json"',title:'"s1-runtime.json"'},'{\n  "target": "bmv2",\n  "p4info": "build/source_routing.p4.p4info.txt",\n  "bmv2_json": "build/source_routing.json",\n  "table_entries": [\n    {\n      "table": "MyIngress.label_exact",\n      "default_action": true,\n      "action_name": "MyIngress.drop",\n      "action_params": { }\n    },\n    {\n      "table": "MyIngress.label_exact",\n      "match": {\n        "hdr.srcRoutes[0].port": 1\n      },\n      "action_name": "MyIngress.label_output",\n      "action_params": {\n        "port": 2\n      }\n    }\n  ]\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="s2-runtime.json"',title:'"s2-runtime.json"'},'{\n  "target": "bmv2",\n  "p4info": "build/source_routing.p4.p4info.txt",\n  "bmv2_json": "build/source_routing.json",\n  "table_entries": [\n    {\n      "table": "MyIngress.label_exact",\n      "default_action": true,\n      "action_name": "MyIngress.drop",\n      "action_params": { }\n    },\n    {\n      "table": "MyIngress.label_exact",\n      "match": {\n        "hdr.srcRoutes[0].port": 1\n      },\n      "action_name": "MyIngress.pop_label_output",\n      "action_params": {\n        "port": 1\n      }\n    }\n  ]\n}\n')),(0,i.kt)("h2",{id:"prerequisite"},"Prerequisite"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Follow the ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/p4lang/tutorials"},"README")," to install the virtual machine. If you are not familiar with vagrant, it just a virtual machine organizer, you can think of it like Docker. (You have to install it before you start the lab.)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"$ cd vm-ubuntu-20.04\n$ vagrant up\n")),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"Wait for about an hour to complete the installation."),(0,i.kt)("li",{parentName:"ol"},"Follow the instructions in this ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/p4lang/tutorials/tree/master/vm-ubuntu-20.04"},"link"),". It will tell you some optional steps to follow up."),(0,i.kt)("li",{parentName:"ol"},"After complete all these step, you can start to compile the code.")),(0,i.kt)("h2",{id:"steps"},"Steps"),(0,i.kt)("p",null,"You can directly modify the code under the ",(0,i.kt)("inlineCode",{parentName:"p"},"tutorials/exercises/source_routing")," or you can copy it before modifying. All instructions below follow this ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/p4lang/tutorials/tree/master/exercises/source_routing"},"instruction"),"."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"After you replace all aforemehtioned files, type make to compile the p4 code and set up mininet nodes.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"p4@p4$ make\n")),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"Open terminal for two hosts.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"mininet> xterm h1 h2\n")),(0,i.kt)("ol",{start:3},(0,i.kt)("li",{parentName:"ol"},"h2 is the receiver.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"h2> ./receive.py\n")),(0,i.kt)("ol",{start:4},(0,i.kt)("li",{parentName:"ol"},"h1 is the sender. (10.0.2.2 is the ip of h2, under ",(0,i.kt)("inlineCode",{parentName:"li"},"topology.json"),")")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"h1> ./send.py 10.0.2.2\n")),(0,i.kt)("ol",{start:5},(0,i.kt)("li",{parentName:"ol"},"You can then inspect the result."),(0,i.kt)("li",{parentName:"ol"},"Delete all resources.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"# Exit mininet\nmininet> exit\n\n# Clean mininet resources\np4@p4$ make stop\np4@p4$ make clean\n")),(0,i.kt)("h2",{id:"result"},"Result"),(0,i.kt)("p",null,"table entries\n",(0,i.kt)("img",{alt:"table-entries",src:n(8486).Z})),(0,i.kt)("p",null,"h1:\n",(0,i.kt)("img",{alt:"h1-send",src:n(4086).Z})),(0,i.kt)("p",null,"h2:\n",(0,i.kt)("img",{alt:"h2-receive",src:n(1666).Z})),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/p4lang/tutorials/tree/master/exercises/basic"},"https://github.com/p4lang/tutorials/tree/master/exercises/basic")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/p4lang/tutorials/tree/master/exercises/source_routing"},"https://github.com/p4lang/tutorials/tree/master/exercises/source_routing"))))}d.isMDXComponent=!0},4086:function(e,t,n){"use strict";t.Z=n.p+"assets/images/P4-lab-h1-send-59d499a417eb178044ec8b31c07177cb.png"},1666:function(e,t,n){"use strict";t.Z=n.p+"assets/images/P4-lab-h2-receive-a5858d66677d7cd796a02426a3337339.png"},5635:function(e,t,n){"use strict";t.Z=n.p+"assets/images/P4-lab-label-topology-edc6d31260ca01c46cfd0a81d33a0e2f.png"},8486:function(e,t,n){"use strict";t.Z=n.p+"assets/images/P4-lab-table-entries-37aa51cd4f1e12860a1cae39ac459398.png"}}]);