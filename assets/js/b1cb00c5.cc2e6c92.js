(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7149],{3905:function(e,n,r){"use strict";r.d(n,{Zo:function(){return s},kt:function(){return g}});var t=r(7294);function o(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function i(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function a(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?i(Object(r),!0).forEach((function(n){o(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function u(e,n){if(null==e)return{};var r,t,o=function(e,n){if(null==e)return{};var r,t,o={},i=Object.keys(e);for(t=0;t<i.length;t++)r=i[t],n.indexOf(r)>=0||(o[r]=e[r]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)r=i[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=t.createContext({}),l=function(e){var n=t.useContext(c),r=n;return e&&(r="function"==typeof e?e(n):a(a({},n),e)),r},s=function(e){var n=l(e.components);return t.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},m=t.forwardRef((function(e,n){var r=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,s=u(e,["components","mdxType","originalType","parentName"]),m=l(r),g=o,d=m["".concat(c,".").concat(g)]||m[g]||p[g]||i;return r?t.createElement(d,a(a({ref:n},s),{},{components:r})):t.createElement(d,a({ref:n},s))}));function g(e,n){var r=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=r.length,a=new Array(i);a[0]=m;var u={};for(var c in n)hasOwnProperty.call(n,c)&&(u[c]=n[c]);u.originalType=e,u.mdxType="string"==typeof e?e:o,a[1]=u;for(var l=2;l<i;l++)a[l]=r[l];return t.createElement.apply(null,a)}return t.createElement.apply(null,r)}m.displayName="MDXCreateElement"},4527:function(e,n,r){"use strict";r.r(n),r.d(n,{frontMatter:function(){return u},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return s},default:function(){return m}});var t=r(4034),o=r(9973),i=(r(7294),r(3905)),a=["components"],u={},c="Go Composite Pattern",l={unversionedId:"Programming/Design Pattern/Patterns/Composite/Go",id:"Programming/Design Pattern/Patterns/Composite/Go",isDocsHomePage:!1,title:"Go Composite Pattern",description:"Geometry Composite",source:"@site/docs/Programming/Design Pattern/Patterns/Composite/Go.md",sourceDirName:"Programming/Design Pattern/Patterns/Composite",slug:"/Programming/Design Pattern/Patterns/Composite/Go",permalink:"/docs/Programming/Design Pattern/Patterns/Composite/Go",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Builder Pattern Overview",permalink:"/docs/Programming/Design Pattern/Patterns/Builder/Overview"},next:{title:"Overview",permalink:"/docs/Programming/Design Pattern/Patterns/Composite/Overview"}},s=[{value:"Geometry Composite",id:"geometry-composite",children:[],level:2},{value:"Neuron Network Composite",id:"neuron-network-composite",children:[],level:2},{value:"References",id:"references",children:[],level:2}],p={toc:s};function m(e){var n=e.components,r=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,t.Z)({},p,r,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"go-composite-pattern"},"Go Composite Pattern"),(0,i.kt)("h2",{id:"geometry-composite"},"Geometry Composite"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"This example demostrate how to embed itself to form a recursive structure")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'type GraphicObject struct {\n  Name, Color string\n  Children []GraphicObject\n}\n\nfunc (g *GraphicObject) String() string {\n  sb := strings.Builder{}\n  g.print(&sb, 0)\n  return sb.String()\n}\n\nfunc (g *GraphicObject) print(sb *strings.Builder, depth int) {\n  sb.WriteString(strings.Repeat("*", depth))\n  if len(g.Color) > 0 {\n    sb.WriteString(g.Color)\n    sb.WriteRune(\' \')\n  }\n  sb.WriteString(g.Name)\n  sb.WriteRune(\'\\n\')\n\n  for _, child := range g.Children {\n    child.print(sb, depth+1)\n  }\n}\n\nfunc NewCircle(color string) *GraphicObject {\n  return &GraphicObject{"Circle", color, nil}\n}\n\nfunc NewSquare(color string) *GraphicObject {\n  return &GraphicObject{"Square", color, nil}\n}\n\nfunc main() {\n  drawing := GraphicObject{"My Drawing", "", nil}\n  drawing.Children = append(drawing.Children, *NewSquare("Red"))\n  drawing.Children = append(drawing.Children, *NewCircle("Yellow"))\n\n  group := GraphicObject{"Group 1", "", nil}\n  group.Children = append(group.Children, *NewCircle("Blue"))\n  group.Children = append(group.Children, *NewSquare("Blue"))\n  drawing.Children = append(drawing.Children, group)\n\n  fmt.Println(drawing.String())\n}\n')),(0,i.kt)("h2",{id:"neuron-network-composite"},"Neuron Network Composite"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"This example is interesting, by utilizing a ",(0,i.kt)("inlineCode",{parentName:"li"},"NeuronInterface"),", it can connect ",(0,i.kt)("inlineCode",{parentName:"li"},"Neuron")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"NeuronLayer")),(0,i.kt)("li",{parentName:"ul"},"It forces two concrete type to conform to an interface, and because the underlying type (",(0,i.kt)("inlineCode",{parentName:"li"},"Neuron"),") is the same, they can concatenate seamlessly.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"type NeuronInterface interface {\n  Iter() []*Neuron\n}\n\ntype Neuron struct {\n  In, Out []*Neuron\n}\n\nfunc (n *Neuron) Iter() []*Neuron {\n  return []*Neuron{n}\n}\n\nfunc (n *Neuron) ConnectTo(other *Neuron) {\n  n.Out = append(n.Out, other)\n  other.In = append(other.In, n)\n}\n\ntype NeuronLayer struct {\n  Neurons []Neuron\n}\n\nfunc (n *NeuronLayer) Iter() []*Neuron {\n  result := make([]*Neuron, 0)\n  for i := range n.Neurons {\n    result = append(result, &n.Neurons[i])\n  }\n  return result\n}\n\nfunc NewNeuronLayer(count int) *NeuronLayer {\n  return &NeuronLayer{make([]Neuron, count)}\n}\n\nfunc Connect(left, right NeuronInterface) {\n  for _, l := range left.Iter() {\n    for _, r := range right.Iter() {\n      l.ConnectTo(r)\n    }\n  }\n}\n\nfunc main() {\n  neuron1, neuron2 := &Neuron{}, &Neuron{}\n  layer1, layer2 := NewNeuronLayer(3), NewNeuronLayer(4)\n\n  Connect(neuron1, neuron2)\n  Connect(neuron1, layer1)\n  Connect(layer2, neuron1)\n  Connect(layer1, layer2)\n}\n")),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.udemy.com/course/design-patterns-go"},"https://www.udemy.com/course/design-patterns-go"))))}m.isMDXComponent=!0}}]);