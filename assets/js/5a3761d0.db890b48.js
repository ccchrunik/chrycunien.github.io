(self.webpackChunkyingchiaochen_website=self.webpackChunkyingchiaochen_website||[]).push([[5731],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(n),m=r,k=d["".concat(s,".").concat(m)]||d[m]||u[m]||l;return n?a.createElement(k,i(i({ref:t},c),{},{components:n})):a.createElement(k,i({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var p=2;p<l;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3666:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return c},default:function(){return d}});var a=n(4034),r=n(9973),l=(n(7294),n(3905)),i=["components"],o={},s="OpenFlow",p={unversionedId:"System/Network/Virtualization/SDN/SDN-OpenFlow",id:"System/Network/Virtualization/SDN/SDN-OpenFlow",isDocsHomePage:!1,title:"OpenFlow",description:"History",source:"@site/docs/System/Network/Virtualization/SDN/SDN-OpenFlow.md",sourceDirName:"System/Network/Virtualization/SDN",slug:"/System/Network/Virtualization/SDN/SDN-OpenFlow",permalink:"/docs/System/Network/Virtualization/SDN/SDN-OpenFlow",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Dimensions of SDN Applications",permalink:"/docs/System/Network/Virtualization/SDN/SDN-Dimensions"},next:{title:"SDN Overview",permalink:"/docs/System/Network/Virtualization/SDN/SDN-Overview"}},c=[{value:"History",id:"history",children:[],level:2},{value:"Switching",id:"switching",children:[],level:2},{value:"Data Plane Abstraction",id:"data-plane-abstraction",children:[{value:"Header",id:"header",children:[],level:3},{value:"Forward Examples",id:"forward-examples",children:[],level:3}],level:2},{value:"Types of Messages",id:"types-of-messages",children:[{value:"Asynchronous",id:"asynchronous",children:[],level:3},{value:"Symmetric",id:"symmetric",children:[],level:3}],level:2},{value:"Message Formats",id:"message-formats",children:[],level:2},{value:"Actions",id:"actions",children:[{value:"Output to switch port",id:"output-to-switch-port",children:[],level:3},{value:"Set fields",id:"set-fields",children:[],level:3},{value:"Others",id:"others",children:[],level:3}],level:2},{value:"Flow Tables",id:"flow-tables",children:[{value:"Forwarding Delay",id:"forwarding-delay",children:[],level:3}],level:2},{value:"Topology Discovery",id:"topology-discovery",children:[{value:"LLDP",id:"lldp",children:[],level:3},{value:"Host Tracking",id:"host-tracking",children:[],level:3}],level:2},{value:"References",id:"references",children:[],level:2}],u={toc:c};function d(e){var t=e.components,o=(0,r.Z)(e,i);return(0,l.kt)("wrapper",(0,a.Z)({},u,o,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"openflow"},"OpenFlow"),(0,l.kt)("h2",{id:"history"},"History"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Developed in Stanford, standardized by Open Networking Foundation (ONF)"),(0,l.kt)("li",{parentName:"ul"},"Current Version 1.5, but version implemented by switch vendors: 1.3")),(0,l.kt)("h2",{id:"switching"},"Switching"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"An OpenFlow switch has two layers: software layer and hardware layer"),(0,l.kt)("li",{parentName:"ul"},"You have to configure a OpenFlow switch by telling the controll's ip address (or other form of address)"),(0,l.kt)("li",{parentName:"ul"},"Software layer communicates with controller, sending network conditions and receiving flow table data"),(0,l.kt)("li",{parentName:"ul"},"Hardware layer is in charge of routing based on the flow table")),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"openflow-switching",src:n(8331).Z})),(0,l.kt)("h2",{id:"data-plane-abstraction"},"Data Plane Abstraction"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Flow: defined by header fields"),(0,l.kt)("li",{parentName:"ul"},"Generalized forwarding: simple packet-handling rules",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Pattern"),": match values in packet header fields"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Actions"),": for matched packet: ",(0,l.kt)("inlineCode",{parentName:"li"},"drop"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"forward"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"modify"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"matched packet")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"send matched packet")," to controller"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Priority"),": disambiguate overlapping patterns"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Counters"),": #bytes and #packets"))),(0,l.kt)("li",{parentName:"ul"},"Rule examples:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"1. src=1.2.*.*, dest=3.4.5.* -> drop\n2. src = *.*.*.*, dest=3.4.*.* -> forward(2)\n3. src=10.1.2.3, dest=*.*.*.* -> send to controller\n")),(0,l.kt)("h3",{id:"header"},"Header"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"openflow-header",src:n(1710).Z})),(0,l.kt)("h3",{id:"forward-examples"},"Forward Examples"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"openflow-forward-examples",src:n(4267).Z})),(0,l.kt)("h2",{id:"types-of-messages"},"Types of Messages"),(0,l.kt)("h3",{id:"asynchronous"},"Asynchronous"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Controller-to-Switch:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Send-packet"),": to send packet out of a specific port on a switch"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Flow-mod"),": to add/delete/modify flows in the flow table"))),(0,l.kt)("li",{parentName:"ul"},"Initiated by the controller (two-way communication):",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Read-state"),": to collect statistics about flow table, ports and individual flows"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Features"),": sent by controller when a switch connects to find out the features supported by a switch"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Configuration"),": to set and query configuration parameters in the switch"))),(0,l.kt)("li",{parentName:"ul"},"Initiated by the switch:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Packet-in"),": for all packets that do not have a matching rule, this event is sent to controller"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Flow-removed"),": whenever a flow rule expires, the controller is sent a flow-removed message"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Port-status"),": whenever a port configuration or state changes, a message is sent to controller"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Error"),": error messages")))),(0,l.kt)("h3",{id:"symmetric"},"Symmetric"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Can be sent in either direction without solicitation"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Hello"),": at connection startup"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Echo"),": to indicate latency, bandwidth or liveliness of a controller-switch connection"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Vendor"),": for extensions (that can be included in later OpenFlow versions)")),(0,l.kt)("h2",{id:"message-formats"},"Message Formats"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Controller encapsulates message into an object",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre"},"- Accessor functions to different fields\n- No need to worry about crafting network packets \n")),(0,l.kt)("img",{alt:"openflow-message-formats",src:n(4969).Z}))),(0,l.kt)("h2",{id:"actions"},"Actions"),(0,l.kt)("h3",{id:"output-to-switch-port"},"Output to switch port"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Physical ports & virtual ports"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ALL")," (all standard ports excluding the ingress port) --\x3e ",(0,l.kt)("inlineCode",{parentName:"li"},"Flooding")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"CONTROLLER")," (encapsulate and send the packet to controller) \u2013-> ",(0,l.kt)("inlineCode",{parentName:"li"},"PACKET_IN")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"LOCAL")," (switch\u2019s stack) ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Go through the IP layer, etc (mostly used for vSwitches)"),(0,l.kt)("li",{parentName:"ul"},"Used for inter-switch communication"),(0,l.kt)("li",{parentName:"ul"},"The normal packets are directly processed by hardward, no messages needed"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"NORMAL")," (process the packet using traditional non-OpenFlow pipeline of the switch) \u2013-> traditional L2 forwarding, L3 routing"),(0,l.kt)("li",{parentName:"ul"},"There are still some types of messages that can send to a single port")),(0,l.kt)("h3",{id:"set-fields"},"Set fields"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Packet modification/header rewriting (every field that OpenFlow supports)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Ethernet Source address"),(0,l.kt)("li",{parentName:"ul"},"Ethernet Dest address"),(0,l.kt)("li",{parentName:"ul"},"IP source & dest addresses, IP ToS, IP ECN, IP TTL, VLAN"),(0,l.kt)("li",{parentName:"ul"},"TCP/UDP source and destination ports"),(0,l.kt)("li",{parentName:"ul"},"..."))),(0,l.kt)("li",{parentName:"ul"},"Therefore, it hards to determine if a packet's fields are changed"),(0,l.kt)("li",{parentName:"ul"},"Payload has a lot of mechanism (MAC, certificate) to ensure integrity, but header is hard (because the designer of the Internet did not consider this an issue)")),(0,l.kt)("h3",{id:"others"},"Others"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Drop"),", like firewall"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Strip")," (pop) the outer VLAN tag"),(0,l.kt)("li",{parentName:"ul"},"Set queue ID when outputting to a port (Enqueue) (QoS, priority queue)"),(0,l.kt)("li",{parentName:"ul"},"Support for matching across multiple tables",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"It can reduces the number of entries"),(0,l.kt)("li",{parentName:"ul"},"Ex: All combinations of 3 ports and 4 ips",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"3 * 4 = 12 in a single table"),(0,l.kt)("li",{parentName:"ul"},"3 + 4 = 7 in two tables"))))),(0,l.kt)("li",{parentName:"ul"},"Support for tunneling"),(0,l.kt)("li",{parentName:"ul"},"Support for Push/Pop mulitple VLAN/MPLS/PBB tags"),(0,l.kt)("li",{parentName:"ul"},"...")),(0,l.kt)("h2",{id:"flow-tables"},"Flow Tables"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The structure of a flow table is like cache in computer systems"),(0,l.kt)("li",{parentName:"ul"},"Steps:")),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Hardware processes rules in a parallel way (TCAM) to find a match. (limited hardware capacity, extremly fast)"),(0,l.kt)("li",{parentName:"ol"},"If not found, it use software tables (hash table) to find one. (Small Memory, fast)"),(0,l.kt)("li",{parentName:"ol"},"If still not found, send a request to controller for rules (more than one table). (Large Memory, slow)")),(0,l.kt)("h3",{id:"forwarding-delay"},"Forwarding Delay"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},'"Tango: Simplifying SDN Control with Automatic Switch Property Inference, Abstraction, and Optimization", Aggelos Lazaris, Daniel Tahara, Xin Huang, Li Erran Li, Andreas Voellmy, Y. Richard Yang, and Minlan Yu, CoNEXT\'14'),(0,l.kt)("li",{parentName:"ul"},"Fast path delay: 0.665 ms"),(0,l.kt)("li",{parentName:"ul"},"Slow path delay: 3.7 ms"),(0,l.kt)("li",{parentName:"ul"},"Control path delay: 7.5 ms")),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"openflow-table",src:n(1781).Z})),(0,l.kt)("h2",{id:"topology-discovery"},"Topology Discovery"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"One switch connect to only one controller. "),(0,l.kt)("li",{parentName:"ul"},"The administrator need to specify a controller's ip to connect to the controller, so controllers know all its switch")),(0,l.kt)("h3",{id:"lldp"},"LLDP"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"An OpenFlow controller discover topology by sending LLDP control messages"),(0,l.kt)("li",{parentName:"ul"},"The controller discover the neighbor of a switch based on where packet-in comes from"),(0,l.kt)("li",{parentName:"ul"},"Steps:")),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"To know SW1's neighbor, the controller send an LLDP ",(0,l.kt)("inlineCode",{parentName:"li"},"PACKET_OUT")," message"),(0,l.kt)("li",{parentName:"ol"},"On receiving the message, SW1 broadcasts the message to all its neighbor"),(0,l.kt)("li",{parentName:"ol"},"When SW2 and SW3 receive the message, they send ",(0,l.kt)("inlineCode",{parentName:"li"},"PACKET_IN")," message to its controller")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Question: What if SW2 or SW3 connect to a different controller"),(0,l.kt)("li",{parentName:"ul"},"Answer: People who use SDN mostly in their own domain, that is, under the same authority, although it may not connect to the same controller (because of distributed controllers), the controllers are likely under the same authority so the logically centralized controller will know the topology.")),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"topology-LLDP",src:n(1708).Z})),(0,l.kt)("h3",{id:"host-tracking"},"Host Tracking"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"It just likes how the traditional Ethernet LAN works"),(0,l.kt)("li",{parentName:"ul"},"Once a host sends a packet, we know this host is under which switch"),(0,l.kt)("li",{parentName:"ul"},"It a host never sends a packet, it doesn't matter because it does not affect the topology")),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"topology-host-tracking",src:n(7869).Z})),(0,l.kt)("h2",{id:"references"},"References"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"This note is based on NTU course - ",(0,l.kt)("a",{parentName:"li",href:"https://nol.ntu.edu.tw/nol/coursesearch/print_table.php?course_id=942%20U0710&class=&dpt_code=9420&ser_no=50698&semester=110-1&lang=CH"},"Network Virtualization and Security"))))}d.isMDXComponent=!0},4267:function(e,t,n){"use strict";t.Z=n.p+"assets/images/openflow-forward-examples-be5dc7845479fdf1765e36020a884465.png"},1710:function(e,t,n){"use strict";t.Z=n.p+"assets/images/openflow-header-5f8268780abecb14642809770c448b07.png"},4969:function(e,t,n){"use strict";t.Z=n.p+"assets/images/openflow-message-formats-3b1b6a315915a4484d96182b56e7976b.png"},8331:function(e,t,n){"use strict";t.Z=n.p+"assets/images/openflow-switching-36b217e4d76a1a6710066876a63a5c1d.png"},1781:function(e,t,n){"use strict";t.Z=n.p+"assets/images/openflow-table-464bedc9f82314ff25f296165432f86b.png"},1708:function(e,t,n){"use strict";t.Z=n.p+"assets/images/topology-LLDP-f4997e1d212e6881644b527d7c53f105.png"},7869:function(e,t,n){"use strict";t.Z=n.p+"assets/images/topology-host-tracking-85f1696985aebc07995ef99c7e71e435.png"}}]);