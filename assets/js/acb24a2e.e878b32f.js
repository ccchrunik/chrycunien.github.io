(self.webpackChunkyingchiaochen_website=self.webpackChunkyingchiaochen_website||[]).push([[3199],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return c},kt:function(){return m}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),d=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=d(e.components);return i.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),p=d(n),m=a,u=p["".concat(l,".").concat(m)]||p[m]||h[m]||o;return n?i.createElement(u,s(s({ref:t},c),{},{components:n})):i.createElement(u,s({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=p;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:a,s[1]=r;for(var d=2;d<o;d++)s[d]=n[d];return i.createElement.apply(null,s)}return i.createElement.apply(null,n)}p.displayName="MDXCreateElement"},7314:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return c},default:function(){return p}});var i=n(4034),a=n(9973),o=(n(7294),n(3905)),s=["components"],r={},l="Multicast",d={unversionedId:"System/Distributed/Concepts/Multicast",id:"System/Distributed/Concepts/Multicast",isDocsHomePage:!1,title:"Multicast",description:"Last Modified: 2021-7-29",source:"@site/docs/System/Distributed/Concepts/Multicast.md",sourceDirName:"System/Distributed/Concepts",slug:"/System/Distributed/Concepts/Multicast",permalink:"/docs/System/Distributed/Concepts/Multicast",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Membership",permalink:"/docs/System/Distributed/Concepts/Membership"},next:{title:"ONOS + mininet",permalink:"/docs/System/Network/Operation/ONOS-Lab"}},c=[{value:"Basic Concepts",id:"basic-concepts",children:[],level:2},{value:"Tree-based Method",id:"tree-based-method",children:[{value:"Steps",id:"steps",children:[],level:3},{value:"Advanced",id:"advanced",children:[{value:"Protocols",id:"protocols",children:[],level:4},{value:"Switch tree",id:"switch-tree",children:[],level:4}],level:3},{value:"Problems",id:"problems",children:[],level:3}],level:2},{value:"Flooding Method",id:"flooding-method",children:[{value:"Algorithm",id:"algorithm",children:[],level:3}],level:2},{value:"Gossip-based Methods",id:"gossip-based-methods",children:[{value:"Algorithm",id:"algorithm-1",children:[{value:"Push",id:"push",children:[],level:4},{value:"Pull",id:"pull",children:[],level:4},{value:"Hybrid",id:"hybrid",children:[],level:4}],level:3}],level:2},{value:"Conclusion",id:"conclusion",children:[],level:2},{value:"Reference",id:"reference",children:[],level:2}],h={toc:c};function p(e){var t=e.components,r=(0,a.Z)(e,s);return(0,o.kt)("wrapper",(0,i.Z)({},h,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"multicast"},"Multicast"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Last Modified: 2021-7-29"),(0,o.kt)("h2",{parentName:"blockquote",id:"introduction"},"Introduction"),(0,o.kt)("p",{parentName:"blockquote"},"In this section, we introduce the concept of ",(0,o.kt)("strong",{parentName:"p"},"multicasting"),". Transport layer protocols like TCP, UDP provide a way to establish point-to-point communication. However, sometimes we want to send a message to several receivers. In this situation, we can still set up the same number of connections using TCP or UDP, but it may not be that efficient and reliable. We want an efficient way to send messages to a group of members, which is called ",(0,o.kt)("strong",{parentName:"p"},"multicasting"),". We will introduce several ways to add an additional layer on the existing communication layer.")),(0,o.kt)("h2",{id:"basic-concepts"},"Basic Concepts"),(0,o.kt)("p",null,"Multicasting is actually a superset of broadcasting. In the broadcasting scenario, the sender send a message to all members in the group. On the other hand, multicasting only send to a group of members inside the whole member set. "),(0,o.kt)("p",null,"In fact, multicasting can be abstracted to broadcasting in a logical way. You can assume that we can build reliable communication between each pair of nodes, no matter how many nodes the connection should pass. Therefore, we can regard multicasting as broadcasting in a logical group. The intermediate nodes are hidden from the logical layer. "),(0,o.kt)("p",null,"With this abstraction, we transform the mulicasting problem to the broadcasting problem. Our goal is to find an efficient way to send message to the whole logical group. It's worth noting that in this section we do not cope with the unreliability of the underlying network. We will address this problem in a separate note."),(0,o.kt)("p",null,"In this node, we introduced 3 basic means of broadcasting: tree-based, flooding-based, and gossip-based methods."),(0,o.kt)("h2",{id:"tree-based-method"},"Tree-based Method"),(0,o.kt)("p",null,"Figure 1. Tree-based Multicast"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"tree-based",src:n(2453).Z})),(0,o.kt)("p",null,"In the tree-based multicasting, we build an minimal spanning tree for a message group, where root is the sender. When the sender want to multicast a messge, it has to first establish this tree. "),(0,o.kt)("h3",{id:"steps"},"Steps"),(0,o.kt)("p",null,"There are several ways to do this thing. A simple way is to:  "),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"The sender generates a message identifier ",(0,o.kt)("inlineCode",{parentName:"p"},"mid"),", which is hashed to a ",(0,o.kt)("inlineCode",{parentName:"p"},"hash(mid)"),". Then the ",(0,o.kt)("inlineCode",{parentName:"p"},"hash(mid)")," is sent to the specific nodes based on the hashed result. We will use ",(0,o.kt)("inlineCode",{parentName:"p"},"m")," as the node label.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"If any node want to receive an message, we send a request to the target node. For example, ",(0,o.kt)("inlineCode",{parentName:"p"},"p")," wants to receive the message of the target ",(0,o.kt)("inlineCode",{parentName:"p"},"m"),", it send a request to ",(0,o.kt)("inlineCode",{parentName:"p"},"m"),". The message will pass along multiple nodes. To make things simple, it will only pass a intermediate node ",(0,o.kt)("inlineCode",{parentName:"p"},"r"),".")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"When node ",(0,o.kt)("inlineCode",{parentName:"p"},"r")," receive the message, if it did not forward the message before, it will forward the message to the next node (in this case ,",(0,o.kt)("inlineCode",{parentName:"p"},"m"),") and mark ",(0,o.kt)("inlineCode",{parentName:"p"},"p")," as a child. Otherwise, if another node ",(0,o.kt)("inlineCode",{parentName:"p"},"t")," send request message through ",(0,o.kt)("inlineCode",{parentName:"p"},"r")," that is not the first time, ",(0,o.kt)("inlineCode",{parentName:"p"},"r")," will only mark ",(0,o.kt)("inlineCode",{parentName:"p"},"t")," as a child, and will not forward the message to ",(0,o.kt)("inlineCode",{parentName:"p"},"m"),".")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Finally, the sender just send the ",(0,o.kt)("inlineCode",{parentName:"p"},"send")," message to node ",(0,o.kt)("inlineCode",{parentName:"p"},"m"),". As a result, the message will be passed along the tree, and each registered node will receive the message. "))),(0,o.kt)("h3",{id:"advanced"},"Advanced"),(0,o.kt)("h4",{id:"protocols"},"Protocols"),(0,o.kt)("h4",{id:"switch-tree"},"Switch tree"),(0,o.kt)("h3",{id:"problems"},"Problems"),(0,o.kt)("p",null,"There are several problems with the tree-based method:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Tree setup and maintainence"),(0,o.kt)("li",{parentName:"ul"},"Only the leaf nodes belong to the message group"),(0,o.kt)("li",{parentName:"ul"},"It cannot withstand single node failure. Recall that in a tree, each pair of nodes has only 1 path between each other. Therefore, if an internal node fail, then all its children will not receive the message.")),(0,o.kt)("h2",{id:"flooding-method"},"Flooding Method"),(0,o.kt)("p",null,"Tree-based method minimize the amount of message passing, but if suffers from single point of failure. To make the multicasting more reliable, we have to pass redundant information, and also send the message through more than one path to prevent message loss.   "),(0,o.kt)("p",null,"To solve this problem, we introduce another method -- ",(0,o.kt)("strong",{parentName:"p"},"flooding"),". A flooding method is that when a node receive a message, it will send message to all its neighbor nodes. The actual implementation may vary, one can use the logical group described above, another can use some internal node for merely passing the message."),(0,o.kt)("p",null,"This type of method has a complexity of ",(0,o.kt)("inlineCode",{parentName:"p"},"O(N^2)")," (",(0,o.kt)("inlineCode",{parentName:"p"},"1/2 * N * (N-1)"),")"),(0,o.kt)("h3",{id:"algorithm"},"Algorithm"),(0,o.kt)("h2",{id:"gossip-based-methods"},"Gossip-based Methods"),(0,o.kt)("p",null,"Gossip-based method is also called epidemic protocol, simulating the distribution of a disease. We borrow this concept to distribute information as quickly as possible. "),(0,o.kt)("p",null,"Gossip-based method is similar to its flooding counterpart, with only a slightly variation. "),(0,o.kt)("p",null,"We assume we can send message to any member in the group. There are 3 types of scenario: push, pull, and hybrid. "),(0,o.kt)("p",null,"The complexity is ",(0,o.kt)("inlineCode",{parentName:"p"},"O(NlogN)"),"."),(0,o.kt)("h3",{id:"algorithm-1"},"Algorithm"),(0,o.kt)("p",null,"The gossip-based method has several rounds, which will run periodically. In the following subsection, we only describe the behavior of each round. It's worth noting that we can assume a state is timestamped or versioned, so the node can correctly choose whether to update the local state based on the image. It is shown that push method has the worst performance, while pull and hybrid is nearly the same."),(0,o.kt)("h4",{id:"push"},"Push"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"We randomly choose a number of nodes as our message receiver."),(0,o.kt)("li",{parentName:"ol"},"We send our local version of state to the receivers."),(0,o.kt)("li",{parentName:"ol"},"We adjust our local version based on the received message.")),(0,o.kt)("h4",{id:"pull"},"Pull"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Periodically, each node randomly choose a list of nodes as message source."),(0,o.kt)("li",{parentName:"ol"},"The node send a request to those nodes asking the state version."),(0,o.kt)("li",{parentName:"ol"},"Based on the response message, we will update the local state.")),(0,o.kt)("h4",{id:"hybrid"},"Hybrid"),(0,o.kt)("p",null,"The hybrid type is the combination of push and pull method."),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"Three types of multicasting -- tree, flooding, gossip -- has different advantage. "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The tree-based method is simple but is not fault-tolerant."),(0,o.kt)("li",{parentName:"ul"},"The flooding-based method is simple and easy to implement, but is not very efficient."),(0,o.kt)("li",{parentName:"ul"},"The gossip-based method use a little more message to serve as redundancy to improve reliability and fault-tolerance.")),(0,o.kt)("p",null,"One have to choose the correct method to implement, there is not one-size-fits-all solution. But for overall performance, I will recomment implement the gossip-based first because of its simplicity and efficiency."),(0,o.kt)("h2",{id:"reference"},"Reference"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Cloud Computing Specialization, Coursera"),(0,o.kt)("li",{parentName:"ul"},"Distributed Systems Principles and Paradigms, Andrew Tanenbaum"),(0,o.kt)("li",{parentName:"ul"},"Distributed Systems: Concepts and Design, George Coulouris")))}p.isMDXComponent=!0},2453:function(e,t,n){"use strict";t.Z=n.p+"assets/images/tree-based-800ea760becc56738682e1eaf9d1c5fa.png"}}]);